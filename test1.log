sect1Head[時戳並行控制
============
]
para[時戳並行控制的基本邏輯如下：

]
para[當一個交易欲存取某一個資料物件，會比較自已與資料物件
上的讀取時戳，來確認存取動作順序不會違反可序列化順序，
若交易動作違反條件，則會立即放棄並重新啟動交易。
*時戳(timestamp)*表示一個即時時刻，且無任兩個時戳相等。
每個交易開始時，會立刻印上一個時戳，稱為交易時戳。

]
listItem[* Ti.ts
]
emptyLine[
]
para[表示交易 Ti 的交易時戳。

]
para[每個資料庫物件會有兩個時戳，讀取時戳和寫入時戳，分別
在讀取或寫入物件時印上其執行者的交易時戳。

]
listItem[* Oi.rts
]
listItem[* Oi.wts
]
emptyLine[
]
para[分別表示資料物件的讀取時戳及寫入時戳。

]
para[資料庫若維持一致，應滿足以下條件：

]
para[若動作 Ai 和 Aj 互為衝突動作，且 Ai 為交易 Ti 的動作，
Aj 為交易 Tj 的動作，若 Ti.ts < Tj.ts，則 Ai 應比 Aj 
早執行。

]
para[若違反上述條件，應立即放棄並重新啟動交易，這和鎖定並行控
制不同，其會暫停交易，等待至可以繼續交易。

]
para[依上述限制，交易 T 正要讀取物件 O 時，應有下面的行為：

]
codeHead[code.交易 T 讀取物件 O
]
para[if T.ts < O.wts 
  T.abort
else
  T.read(O)
  O.rts = max(T.ts, O.rts)

]
para[令 Tw 表示最後寫入 O 的交易，上面則意指 T.ts < Tw.ts，
由於 T.r(O) 與 Tw.w(O) 互為衝突動作，故依上述限制 T.r(O) 
必須早於 Tw.w(O)，所以讀取物件 O 的動作違反上述限制，
T 立即放棄並重新啟動交易。

]
para[其餘情況則 T 讀取 O，
並重設 O.rts=max(T.ts, O.rts)。

]
para[依上述限制，交易 T 正要寫入物件 O 時，應有下面的行為：

]
codeHead[code.交易 T 寫入物件 O 
]
codeBlock[if T.ts < O.rts 
  T.abort
elif T.ts < O.wts
  T.skip
else
  T.write(O)
  O.wts = T.ts
::
]
emptyLine[
]
para[湯瑪式寫入法則(Thomas Write Rule)
---------------------------------
若 T1.ts < T2.ts，則 T1 對 A 的寫入會被 T2 對 A 的寫入
取代，但不會造成衝突動作，故可以忽略 T1 對 A 的寫入。 
這與上述正要讀取物件不同在於，讀取可以讓很多交易同時進行，
所以其 O.rts 可能會大於 T.ts，但寫入永遠只能一個，所以直接
將 O.wts 設為 T.ts。
]
There are 24 tokens.
