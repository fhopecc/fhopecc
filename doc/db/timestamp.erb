時戳並行控制
============
時戳並行控制的基本邏輯如下：
當一個交易欲存取某一個資料物件，
會比較自已與資料物件上的讀取時戳，
來確認存取動作順序不會違反可序列化順序，
若交易動作違反條件，則會立即放棄並重新啟動交易。
時戳(timestamp)表示一個即時時刻，
且無任兩個時戳相等。
每個交易開始時，會立刻印上一個時戳，
稱為交易時戳，
Ti.ts
表示交易 Ti的交易時戳。
每個資料庫物件會有兩個時戳，
讀取時戳和寫入時戳
分別在讀取或寫入物件時印上其執行者的交易時戳，
Oi.rts及
Oi.wts
分別表示資料物件的讀取時戳及寫入時戳。
% end
% paragraph do
資料庫若維持一致，應滿足以下條件：
若動作 Ai 和 Aj 互為衝突動作，
且 Ai 為交易 Ti 的動作，
Aj 為交易 Tj 的動作，
若 Ti.ts &lt; Tj.ts，
則 Ai 應比 Aj 早執行。
% end
% paragraph do
若違反上述條件，應立即放棄並重新啟動交易，
這和鎖定並行控制不同，其會暫停交易，等待至可以繼續交易。
% end
% paragraph do
依上述限制，交易 T 正要讀取物件 O 時，應有下面的行為：
% end
% paragraph do
若 T.ts &lt; O.wts則 T 立即放棄並重新啟動交易。
令 Tw 表示最後寫入 O 的交易，
上面則意指T.ts &lt; Tw.ts，
由於 T.r(O) 與 Tw.w(O) 互為衝突動作，
故依上述限制 T.r(O) 必須早於 Tw.w(O)，
所以讀取物件 O 的動作違反上述限制，T 立即放棄並重新啟動交易。
% end
% paragraph do
其餘情況則 T 讀取 O，
並重設 O.rts=max(T.ts, O.rts)。
% end
% paragraph do
依上述限制，交易 T 正要寫入物件 O 時，應有下面的行為：
% end
% paragraph do
若 T.ts &lt; O.rts則 T 立即放棄並重新啟動交易。
% end
% paragraph do
若 T.ts &lt; O.wts則 T 立即放棄，但不重新啟動。
% end
% paragraph do
這是湯瑪式寫入法則(Thomas Write Rule)，
一個衝突可序列化排程
"pic/thomas_write_rule1.png"
另一個衝突可序列化排程
pic/thomas_write_rule2.png" 
如上兩圖，若 T1.ts &lt; T2.ts，
則 T1 對 A 的寫入會被 
T2 對 A 的寫入取代，
但不會造成衝突動作，故可以忽略 T1 對 A 的寫入。 
% end
% paragraph do
其餘情況則 T 寫入 O，
並重設 O.wts=T.ts。
% end
% paragraph do
這與上述正要讀取物件不同在於，
讀取可以讓很多交易同時進行，所以其 O.rts 可能會大於 T.ts，
但寫入永遠只能一個，所以直接將 O.wts 設為 T.ts
% end
<%end%>
